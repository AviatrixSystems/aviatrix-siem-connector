# Zabbix Metrics Output
# Sends gateway metrics to Zabbix via trapper protocol (Dependent Items pattern)
#
# Each event type sends a single JSON blob to a master trapper item;
# Zabbix 7.x JSONPath preprocessing fans out into individual metrics.
#
# Environment Variables:
#   ZABBIX_SERVER      - Zabbix server/proxy hostname or IP (required)
#   ZABBIX_PORT        - Zabbix trapper port (default: 10051)
#   ZABBIX_HOST_PREFIX - Prefix for Zabbix host names (default: "")
#   LOG_PROFILE        - Which log types to forward (default: all)

# Build Zabbix JSON payload for gateway system stats
filter {
    if "gw_sys_stats" in [tags] and "${ZABBIX_SERVER:}" != "" {
        ruby {
            id => "zabbix-build-sys-stats-json"
            code => '
                require "json"

                prefix = ENV.fetch("ZABBIX_HOST_PREFIX", "")
                gw = event.get("gateway") || "unknown"

                payload = {}

                # CPU aggregate
                cpu_idle = event.get("cpu_idle")
                if cpu_idle
                    idle_f = cpu_idle.to_f
                    payload["cpu_idle"] = idle_f
                    payload["cpu_usage"] = (100 - idle_f).round(2)
                end

                # Memory (raw values are kB from grok, converted to integer by filter 95)
                mem_avail = event.get("memory_available")
                mem_total = event.get("memory_total")
                mem_free  = event.get("memory_free")
                if mem_total
                    total_f = mem_total.to_f
                    avail_f = mem_avail.to_f
                    free_f  = mem_free.to_f
                    payload["memory_available"] = (avail_f * 1024).to_i
                    payload["memory_total"]     = (total_f * 1024).to_i
                    payload["memory_free"]      = (free_f * 1024).to_i
                    payload["memory_used"]      = ((total_f - avail_f) * 1024).to_i
                    if total_f > 0
                        payload["memory_usage"] = ((1.0 - avail_f / total_f) * 100).round(2)
                    end
                end

                # Disk (raw values are kB from grok, converted to integer by filter 95)
                disk_total = event.get("disk_total")
                disk_free  = event.get("disk_free")
                if disk_total
                    dt_f = disk_total.to_f
                    df_f = disk_free.to_f
                    payload["disk_available"] = (df_f * 1024).to_i
                    payload["disk_total"]     = (dt_f * 1024).to_i
                    payload["disk_used"]      = ((dt_f - df_f) * 1024).to_i
                    if dt_f > 0
                        payload["disk_usage"] = ((1.0 - df_f / dt_f) * 100).round(2)
                    end
                end

                # Per-core CPU metrics (from filter 17 cpu_cores_parsed)
                cpu_cores_parsed = event.get("cpu_cores_parsed")
                if cpu_cores_parsed.is_a?(Array)
                    core_count = 0
                    cpu_cores_parsed.each do |core|
                        name = core["name"]
                        next unless name
                        next if name == "-1"  # skip aggregate

                        idx = name.to_i
                        core_count += 1
                        if core["busy_avg"]
                            busy = core["busy_avg"].to_f
                            payload["cpu_core_#{idx}_idle"]  = (100 - busy).round(2)
                            payload["cpu_core_#{idx}_usage"] = busy.round(2)
                        end
                    end
                    payload["cpu_core_count"] = core_count if core_count > 0
                end

                event.set("[@metadata][zabbix_host]", "#{prefix}#{gw}")
                event.set("[@metadata][zabbix_key]", "aviatrix.sys_stats.raw")
                event.set("[@metadata][zabbix_value]", payload.to_json)
            '
        }
    }
}

# Build Zabbix JSON payload for gateway network stats
filter {
    if "gw_net_stats" in [tags] and "${ZABBIX_SERVER:}" != "" {
        ruby {
            id => "zabbix-build-net-stats-json"
            code => '
                require "json"

                prefix = ENV.fetch("ZABBIX_HOST_PREFIX", "")
                gw = event.get("gateway") || "unknown"
                iface = event.get("interface") || "eth0"

                # Parse human-readable byte strings to numeric bytes
                # Handles: "54.07Kb" "2.49GB" "510.30MB" "3.73" "13.45KB"
                parse_to_bytes = lambda do |val|
                    return nil unless val
                    s = val.to_s.strip
                    return nil if s.empty?
                    m = s.match(/\A([\d.]+)\s*(KB|MB|GB|TB|Kb|Mb|Gb|B)?\z/i)
                    return s.to_f unless m
                    num = m[1].to_f
                    unit = m[2]
                    return num unless unit
                    case unit
                    when "B"
                        num
                    when "Kb", "KB", "kb"
                        num * 1024
                    when "Mb", "MB", "mb"
                        num * 1024 * 1024
                    when "Gb", "GB", "gb"
                        num * 1024 * 1024 * 1024
                    when "Tb", "TB", "tb"
                        num * 1024 * 1024 * 1024 * 1024
                    else
                        num
                    end
                end

                payload = {}

                # Rate metrics (from raw strings preserved in [@metadata] by filter 94)
                rx_rate = parse_to_bytes.call(event.get("[@metadata][raw_total_rx_rate]"))
                tx_rate = parse_to_bytes.call(event.get("[@metadata][raw_total_tx_rate]"))
                rxtx_rate = parse_to_bytes.call(event.get("[@metadata][raw_total_rx_tx_rate]"))

                payload["bytes_rx"]         = rx_rate.round(2) if rx_rate
                payload["bytes_tx"]         = tx_rate.round(2) if tx_rate
                payload["bytes_total_rate"] = rxtx_rate.round(2) if rxtx_rate

                # Cumulative metrics (from raw strings preserved in [@metadata] by filter 94)
                rx_cum = parse_to_bytes.call(event.get("[@metadata][raw_total_rx_cum]"))
                tx_cum = parse_to_bytes.call(event.get("[@metadata][raw_total_tx_cum]"))
                rxtx_cum = parse_to_bytes.call(event.get("[@metadata][raw_total_rx_tx_cum]"))

                payload["rx_cumulative"]   = rx_cum.round(2) if rx_cum
                payload["tx_cumulative"]   = tx_cum.round(2) if tx_cum
                payload["rxtx_cumulative"] = rxtx_cum.round(2) if rxtx_cum

                # Conntrack gauge metrics
                ct_count = event.get("conntrack_count")
                payload["conntrack_count"] = ct_count.to_i if ct_count && ct_count.to_s != ""

                ct_avail = event.get("conntrack_allowance_available")
                payload["conntrack_available"] = ct_avail.to_i if ct_avail && ct_avail.to_s != ""

                ct_usage = event.get("conntrack_usage_rate")
                if ct_usage && ct_usage.to_s != ""
                    payload["conntrack_usage"] = (ct_usage.to_f * 100).round(2)
                end

                # Limit-exceeded counters
                %w[conntrack_limit_exceeded bw_in_limit_exceeded bw_out_limit_exceeded pps_limit_exceeded linklocal_limit_exceeded].each do |field|
                    val = event.get(field)
                    payload[field] = val.to_i if val && val.to_s != ""
                end

                event.set("[@metadata][zabbix_host]", "#{prefix}#{gw}")
                event.set("[@metadata][zabbix_key]", "aviatrix.net_stats.raw[#{iface}]")
                event.set("[@metadata][zabbix_value]", payload.to_json)
            '
        }
    }
}

output {
    if "gw_sys_stats" in [tags] and ("${LOG_PROFILE:all}" == "all" or "${LOG_PROFILE:all}" == "networking") {
        zabbix {
            id => "zabbix-sys-stats"
            zabbix_server_host => "${ZABBIX_SERVER}"
            zabbix_server_port => "${ZABBIX_PORT:10051}"
            zabbix_host => "[@metadata][zabbix_host]"
            zabbix_key => "[@metadata][zabbix_key]"
            zabbix_value => "[@metadata][zabbix_value]"
            timeout => 5
        }
    }

    if "gw_net_stats" in [tags] and ("${LOG_PROFILE:all}" == "all" or "${LOG_PROFILE:all}" == "networking") {
        zabbix {
            id => "zabbix-net-stats"
            zabbix_server_host => "${ZABBIX_SERVER}"
            zabbix_server_port => "${ZABBIX_PORT:10051}"
            zabbix_host => "[@metadata][zabbix_host]"
            zabbix_key => "[@metadata][zabbix_key]"
            zabbix_value => "[@metadata][zabbix_value]"
            timeout => 5
        }
    }
}
