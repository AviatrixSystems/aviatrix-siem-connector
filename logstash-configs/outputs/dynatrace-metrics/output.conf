# Dynatrace Metrics Ingest API Output (MINT protocol)
# Sends gateway metrics as time-series data to Dynatrace
#
# Environment Variables:
#   DT_ENVIRONMENT_ID  - Dynatrace environment ID (e.g., abc12345)
#   DT_API_TOKEN       - Dynatrace API token with "metrics.ingest" scope
#   DT_REGION          - Dynatrace region: "live" (default), "apps", or custom domain
#   LOG_PROFILE        - Which log types to forward (default: all)
#                        - all: Forward all metrics
#                        - operations: gw_net_stats, gw_sys_stats
#
# MINT Format: metric.name,dimension="value" gauge,VALUE TIMESTAMP_MS
# See: https://docs.dynatrace.com/docs/dynatrace-api/environment-api/metric-v2/post-ingest-metrics

# Build MINT payload for gateway network stats
filter {
    if "gw_net_stats" in [tags] {
        ruby {
            id => "dynatrace-build-net-stats-mint"
            code => '
                gw_name = event.get("gateway") || "unknown"
                gw_alias = event.get("alias") || gw_name
                timestamp_ms = (event.get("@timestamp").to_f * 1000).to_i

                mint_lines = []

                # Network throughput metrics (rates in bytes)
                def self.parse_rate(val)
                    return 0 unless val
                    m = val.to_s.match(/([\d.]+)(B|Kb|Mb|Gb|KB|MB|GB|TB)?/i)
                    return 0 unless m
                    num = m[1].to_f
                    unit = (m[2] || "B").upcase
                    multipliers = {"B"=>1,"KB"=>1024,"MB"=>1024**2,"GB"=>1024**3,"TB"=>1024**4,"Kb"=>1024,"Mb"=>1024**2,"Gb"=>1024**3}
                    num * (multipliers[m[2]] || 1)
                end

                # Throughput metrics
                rx_rate = parse_rate(event.get("total_rx_rate"))
                tx_rate = parse_rate(event.get("total_tx_rate"))
                rx_tx_rate = parse_rate(event.get("total_rx_tx_rate"))

                mint_lines << "aviatrix.gateway.net.rx.rate.bytes,gateway.name=\"#{gw_alias}\" gauge,#{rx_rate.to_i} #{timestamp_ms}"
                mint_lines << "aviatrix.gateway.net.tx.rate.bytes,gateway.name=\"#{gw_alias}\" gauge,#{tx_rate.to_i} #{timestamp_ms}"
                mint_lines << "aviatrix.gateway.net.total.rate.bytes,gateway.name=\"#{gw_alias}\" gauge,#{rx_tx_rate.to_i} #{timestamp_ms}"

                # Conntrack metrics
                %w[conntrack_count conntrack_allowance_available conntrack_limit_exceeded].each do |field|
                    val = event.get(field)
                    if val && val.to_s != ""
                        metric_name = "aviatrix.gateway.net.#{field.gsub("_", ".")}"
                        mint_lines << "#{metric_name},gateway.name=\"#{gw_alias}\" gauge,#{val.to_i} #{timestamp_ms}"
                    end
                end

                # Bandwidth/PPS limit exceeded counters
                %w[bw_in_limit_exceeded bw_out_limit_exceeded pps_limit_exceeded linklocal_limit_exceeded].each do |field|
                    val = event.get(field)
                    if val && val.to_s != ""
                        metric_name = "aviatrix.gateway.net.#{field.gsub("_", ".")}"
                        mint_lines << "#{metric_name},gateway.name=\"#{gw_alias}\" count,#{val.to_i} #{timestamp_ms}"
                    end
                end

                # Conntrack usage rate
                usage_rate = event.get("conntrack_usage_rate")
                if usage_rate && usage_rate.to_s != ""
                    mint_lines << "aviatrix.gateway.net.conntrack.usage.rate,gateway.name=\"#{gw_alias}\" gauge,#{usage_rate.to_f} #{timestamp_ms}"
                end

                event.set("[@metadata][dynatrace_mint_payload]", mint_lines.join("\n")) unless mint_lines.empty?
            '
        }
    }
}

# Build MINT payload for gateway system stats
filter {
    if "gw_sys_stats" in [tags] {
        ruby {
            id => "dynatrace-build-sys-stats-mint"
            code => '
                gw_name = event.get("gateway") || "unknown"
                gw_alias = event.get("alias") || gw_name
                timestamp_ms = (event.get("@timestamp").to_f * 1000).to_i

                mint_lines = []

                # Overall CPU metrics
                cpu_idle = event.get("cpu_idle")
                cpu_busy = event.get("cpu_busy") || (cpu_idle ? 100 - cpu_idle.to_i : nil)
                if cpu_busy
                    mint_lines << "aviatrix.gateway.cpu.busy.pct,gateway.name=\"#{gw_alias}\" gauge,#{cpu_busy} #{timestamp_ms}"
                end

                # Memory metrics
                mem_total = event.get("memory_total").to_f
                mem_avail = event.get("memory_available").to_f
                mem_free = event.get("memory_free").to_i
                if mem_total > 0 && mem_avail
                    mem_used_pct = ((1.0 - mem_avail / mem_total) * 100).round(2)
                    mint_lines << "aviatrix.gateway.memory.used.pct,gateway.name=\"#{gw_alias}\" gauge,#{mem_used_pct} #{timestamp_ms}"
                    mint_lines << "aviatrix.gateway.memory.available.kb,gateway.name=\"#{gw_alias}\" gauge,#{mem_avail.to_i} #{timestamp_ms}"
                    mint_lines << "aviatrix.gateway.memory.free.kb,gateway.name=\"#{gw_alias}\" gauge,#{mem_free} #{timestamp_ms}"
                end

                # Disk metrics
                disk_total = event.get("disk_total").to_f
                disk_free = event.get("disk_free").to_f
                if disk_total > 0 && disk_free
                    disk_used_pct = ((1.0 - disk_free / disk_total) * 100).round(2)
                    mint_lines << "aviatrix.gateway.disk.used.pct,gateway.name=\"#{gw_alias}\" gauge,#{disk_used_pct} #{timestamp_ms}"
                    mint_lines << "aviatrix.gateway.disk.free.kb,gateway.name=\"#{gw_alias}\" gauge,#{disk_free.to_i} #{timestamp_ms}"
                end

                # Per-core CPU metrics (only if cores were parsed)
                cpu_cores_parsed = event.get("cpu_cores_parsed")
                if cpu_cores_parsed && cpu_cores_parsed.is_a?(Array)
                    cpu_cores_parsed.each do |core|
                        core_id = core["name"] == "-1" ? "aggregate" : core["name"]

                        if core["busy_max"]
                            mint_lines << "aviatrix.gateway.cpu.core.busy.max,gateway.name=\"#{gw_alias}\",core.id=\"#{core_id}\" gauge,#{core["busy_max"]} #{timestamp_ms}"
                        end
                        if core["busy_avg"]
                            mint_lines << "aviatrix.gateway.cpu.core.busy.avg,gateway.name=\"#{gw_alias}\",core.id=\"#{core_id}\" gauge,#{core["busy_avg"]} #{timestamp_ms}"
                        end
                        if core["busy_min"]
                            mint_lines << "aviatrix.gateway.cpu.core.busy.min,gateway.name=\"#{gw_alias}\",core.id=\"#{core_id}\" gauge,#{core["busy_min"]} #{timestamp_ms}"
                        end
                    end
                end

                # High core count summary metrics
                if event.get("high_core_count_gateway")
                    max_peak = event.get("cpu_individual_max_peak")
                    avg_mean = event.get("cpu_individual_avg_mean")
                    cores_over_80 = event.get("cpu_cores_over_80_pct")
                    cores_over_90 = event.get("cpu_cores_over_90_pct")
                    core_count = event.get("cpu_core_count")

                    mint_lines << "aviatrix.gateway.cpu.individual.max.peak,gateway.name=\"#{gw_alias}\" gauge,#{max_peak} #{timestamp_ms}" if max_peak
                    mint_lines << "aviatrix.gateway.cpu.individual.avg.mean,gateway.name=\"#{gw_alias}\" gauge,#{avg_mean.round(2)} #{timestamp_ms}" if avg_mean
                    mint_lines << "aviatrix.gateway.cpu.cores.over.80.pct,gateway.name=\"#{gw_alias}\" gauge,#{cores_over_80} #{timestamp_ms}" if cores_over_80
                    mint_lines << "aviatrix.gateway.cpu.cores.over.90.pct,gateway.name=\"#{gw_alias}\" gauge,#{cores_over_90} #{timestamp_ms}" if cores_over_90
                    mint_lines << "aviatrix.gateway.cpu.core.count,gateway.name=\"#{gw_alias}\" gauge,#{core_count} #{timestamp_ms}" if core_count
                end

                event.set("[@metadata][dynatrace_mint_payload]", mint_lines.join("\n")) unless mint_lines.empty?
            '
        }
    }
}

output {
    # Send metrics to Dynatrace Metrics Ingest API v2
    if [@metadata][dynatrace_mint_payload] {
        if ("gw_net_stats" in [tags] or "gw_sys_stats" in [tags]) and ("${LOG_PROFILE:all}" == "all" or "${LOG_PROFILE:all}" == "operations") {
            http {
                id => "dynatrace-metrics"
                http_method => "post"
                url => "https://${DT_ENVIRONMENT_ID}.${DT_REGION:live}.dynatrace.com/api/v2/metrics/ingest"
                headers => {
                    "Authorization" => "Api-Token ${DT_API_TOKEN}"
                }
                content_type => "text/plain; charset=utf-8"
                format => "message"
                message => "%{[@metadata][dynatrace_mint_payload]}"
                pool_max => 10
                pool_max_per_route => 5
                socket_timeout => 30
            }
        }
    }
}
