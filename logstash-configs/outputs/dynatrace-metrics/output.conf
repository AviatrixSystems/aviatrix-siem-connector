# Dynatrace Metrics Ingest API Output (MINT protocol)
# Sends gateway metrics as time-series data to Dynatrace
#
# Environment Variables:
#   DT_METRICS_URL     - Full Dynatrace metrics ingest URL
#                        e.g. https://abc12345.live.dynatrace.com/api/v2/metrics/ingest
#   DT_API_TOKEN       - Dynatrace API token with "metrics.ingest" scope
#   DT_METRIC_SOURCE   - Source dimension value (default: "aviatrix")
#   LOG_PROFILE        - Which log types to forward (default: all)
#                        - all: Forward all metrics
#                        - networking: gw_net_stats, gw_sys_stats
#
# MINT Format: metric.key,dim1="val1",dim2="val2" gauge,VALUE TIMESTAMP_MS
# See: https://docs.dynatrace.com/docs/dynatrace-api/environment-api/metric-v2/post-ingest-metrics

# Build MINT payload for gateway system stats
filter {
    if "gw_sys_stats" in [tags] {
        ruby {
            id => "dynatrace-build-sys-stats-mint"
            code => '
                gw = event.get("gateway") || "unknown"
                ali = event.get("alias") || gw
                src = ENV.fetch("DT_METRIC_SOURCE", "aviatrix")
                ts = (event.get("@timestamp").to_f * 1000).to_i

                # Escape dimension values for MINT protocol
                esc = lambda { |v| v.to_s.gsub("\\", "\\\\").gsub("\"", "\\\"") }

                dims = "gateway=\"#{esc.call(gw)}\",alias=\"#{esc.call(ali)}\",source=\"#{esc.call(src)}\""
                lines = []

                # CPU metrics
                cpu_idle = event.get("cpu_idle")
                if cpu_idle
                    idle_f = cpu_idle.to_f
                    lines << "aviatrix.gateway.cpu.idle,#{dims} gauge,#{idle_f} #{ts}"
                    lines << "aviatrix.gateway.cpu.usage,#{dims} gauge,#{(100 - idle_f).round(2)} #{ts}"
                end

                # Memory metrics (raw values are kB, convert to bytes)
                mem_avail = event.get("memory_available")
                mem_total = event.get("memory_total")
                mem_free  = event.get("memory_free")
                if mem_avail && mem_total
                    avail_f = mem_avail.to_f
                    total_f = mem_total.to_f
                    free_f  = mem_free.to_f

                    lines << "aviatrix.gateway.memory.avail,#{dims} gauge,#{(avail_f * 1024).to_i} #{ts}"
                    lines << "aviatrix.gateway.memory.total,#{dims} gauge,#{(total_f * 1024).to_i} #{ts}"
                    lines << "aviatrix.gateway.memory.free,#{dims} gauge,#{(free_f * 1024).to_i} #{ts}"
                    lines << "aviatrix.gateway.memory.used,#{dims} gauge,#{((total_f - avail_f) * 1024).to_i} #{ts}"
                    if total_f > 0
                        lines << "aviatrix.gateway.memory.usage,#{dims} gauge,#{((1.0 - avail_f / total_f) * 100).round(2)} #{ts}"
                    end
                end

                # Disk metrics (raw values are kB, convert to bytes)
                disk_total = event.get("disk_total")
                disk_free  = event.get("disk_free")
                if disk_total && disk_free
                    dt_f = disk_total.to_f
                    df_f = disk_free.to_f

                    lines << "aviatrix.gateway.disk.avail,#{dims} gauge,#{(df_f * 1024).to_i} #{ts}"
                    lines << "aviatrix.gateway.disk.total,#{dims} gauge,#{(dt_f * 1024).to_i} #{ts}"
                    lines << "aviatrix.gateway.disk.used,#{dims} gauge,#{((dt_f - df_f) * 1024).to_i} #{ts}"
                    if dt_f > 0
                        lines << "aviatrix.gateway.disk.used.percent,#{dims} gauge,#{((1.0 - df_f / dt_f) * 100).round(2)} #{ts}"
                    end
                end

                # Per-core CPU metrics (from filter 17 cpu_cores_parsed)
                cpu_cores_parsed = event.get("cpu_cores_parsed")
                if cpu_cores_parsed.is_a?(Array)
                    cpu_cores_parsed.each do |core|
                        core_name = core["name"]
                        next unless core_name
                        core_dim = core_name == "-1" ? "aggregate" : core_name
                        cdims = "#{dims},core=\"#{esc.call(core_dim)}\""

                        if core["busy_avg"]
                            busy = core["busy_avg"].to_f
                            lines << "aviatrix.gateway.cpu.idle,#{cdims} gauge,#{(100 - busy).round(2)} #{ts}"
                            lines << "aviatrix.gateway.cpu.usage,#{cdims} gauge,#{busy} #{ts}"
                        end
                    end
                end

                event.set("[@metadata][dynatrace_mint_payload]", lines.join("\n")) unless lines.empty?
            '
        }
    }
}

# Build MINT payload for gateway network stats
filter {
    if "gw_net_stats" in [tags] {
        ruby {
            id => "dynatrace-build-net-stats-mint"
            code => '
                gw = event.get("gateway") || "unknown"
                ali = event.get("alias") || gw
                src = ENV.fetch("DT_METRIC_SOURCE", "aviatrix")
                ts = (event.get("@timestamp").to_f * 1000).to_i
                iface = event.get("interface") || "unknown"
                pub_ip = event.get("public_ip")
                priv_ip = event.get("private_ip") || "unknown"

                esc = lambda { |v| v.to_s.gsub("\\", "\\\\").gsub("\"", "\\\"") }

                dims = "gateway=\"#{esc.call(gw)}\",alias=\"#{esc.call(ali)}\",source=\"#{esc.call(src)}\""
                dims += ",interface=\"#{esc.call(iface)}\""
                dims += ",public_ip=\"#{esc.call(pub_ip)}\"" if pub_ip && pub_ip.to_s != ""
                dims += ",private_ip=\"#{esc.call(priv_ip)}\""

                # Parse human-readable byte strings to numeric bytes
                # Handles: "54.07Kb" "2.49GB" "510.30MB" "3.73" "13.45KB"
                parse_to_bytes = lambda do |val|
                    return nil unless val
                    s = val.to_s.strip
                    return nil if s.empty?
                    m = s.match(/\A([\d.]+)\s*(KB|MB|GB|TB|Kb|Mb|Gb|B)?\z/i)
                    return s.to_f unless m
                    num = m[1].to_f
                    unit = m[2]
                    return num unless unit
                    case unit
                    when "B"
                        num
                    when "Kb", "KB", "kb"
                        num * 1024
                    when "Mb", "MB", "mb"
                        num * 1024 * 1024
                    when "Gb", "GB", "gb"
                        num * 1024 * 1024 * 1024
                    when "Tb", "TB", "tb"
                        num * 1024 * 1024 * 1024 * 1024
                    else
                        num
                    end
                end

                lines = []

                # Rate metrics (from raw strings preserved in [@metadata] by filter 94)
                rx_rate = parse_to_bytes.call(event.get("[@metadata][raw_total_rx_rate]"))
                tx_rate = parse_to_bytes.call(event.get("[@metadata][raw_total_tx_rate]"))
                rxtx_rate = parse_to_bytes.call(event.get("[@metadata][raw_total_rx_tx_rate]"))

                lines << "aviatrix.gateway.net.bytes_rx,#{dims} gauge,#{rx_rate.round(2)} #{ts}" if rx_rate
                lines << "aviatrix.gateway.net.bytes_tx,#{dims} gauge,#{tx_rate.round(2)} #{ts}" if tx_rate
                lines << "aviatrix.gateway.net.bytes_total_rate,#{dims} gauge,#{rxtx_rate.round(2)} #{ts}" if rxtx_rate

                # Cumulative metrics (from raw strings preserved in [@metadata] by filter 94)
                rx_cum = parse_to_bytes.call(event.get("[@metadata][raw_total_rx_cum]"))
                tx_cum = parse_to_bytes.call(event.get("[@metadata][raw_total_tx_cum]"))
                rxtx_cum = parse_to_bytes.call(event.get("[@metadata][raw_total_rx_tx_cum]"))

                lines << "aviatrix.gateway.net.rx_cumulative,#{dims} gauge,#{rx_cum.round(2)} #{ts}" if rx_cum
                lines << "aviatrix.gateway.net.tx_cumulative,#{dims} gauge,#{tx_cum.round(2)} #{ts}" if tx_cum
                lines << "aviatrix.gateway.net.rx_tx_cumulative,#{dims} gauge,#{rxtx_cum.round(2)} #{ts}" if rxtx_cum

                # Conntrack gauge metrics
                ct_count = event.get("conntrack_count")
                lines << "aviatrix.gateway.net.conntrack.count,#{dims} gauge,#{ct_count.to_i} #{ts}" if ct_count && ct_count.to_s != ""

                ct_avail = event.get("conntrack_allowance_available")
                lines << "aviatrix.gateway.net.conntrack.avail,#{dims} gauge,#{ct_avail.to_i} #{ts}" if ct_avail && ct_avail.to_s != ""

                ct_usage = event.get("conntrack_usage_rate")
                if ct_usage && ct_usage.to_s != ""
                    lines << "aviatrix.gateway.net.conntrack.usage,#{dims} gauge,#{(ct_usage.to_f * 100).round(2)} #{ts}"
                end

                # Limit-exceeded count metrics (delta counters)
                %w[conntrack_limit_exceeded bw_in_limit_exceeded bw_out_limit_exceeded pps_limit_exceeded linklocal_limit_exceeded].each do |field|
                    val = event.get(field)
                    if val && val.to_s != ""
                        lines << "aviatrix.gateway.net.#{field},#{dims} count,delta=#{val.to_i} #{ts}"
                    end
                end

                event.set("[@metadata][dynatrace_mint_payload]", lines.join("\n")) unless lines.empty?
            '
        }
    }
}

output {
    # Send metrics to Dynatrace Metrics Ingest API v2
    if [@metadata][dynatrace_mint_payload] {
        if ("gw_net_stats" in [tags] or "gw_sys_stats" in [tags]) and ("${LOG_PROFILE:all}" == "all" or "${LOG_PROFILE:all}" == "networking") {
            http {
                id => "dynatrace-metrics"
                http_method => "post"
                url => "${DT_METRICS_URL}"
                headers => {
                    "Authorization" => "Bearer ${DT_API_TOKEN}"
                }
                content_type => "text/plain; charset=utf-8"
                format => "message"
                message => "%{[@metadata][dynatrace_mint_payload]}"
                pool_max => 10
                pool_max_per_route => 5
                socket_timeout => 30
            }
        }
    }
}
