# Dynatrace Logs Ingest API Output
# Sends Aviatrix event logs as structured JSON to Dynatrace
#
# Environment Variables:
#   DT_LOGS_URL      - Full Dynatrace logs ingest URL
#                      e.g. https://abc12345.live.dynatrace.com/api/v2/logs/ingest
#   DT_LOGS_TOKEN    - Dynatrace API token with "logs.ingest" scope
#   DT_LOG_SOURCE    - log.source attribute value (default: "aviatrix")
#   LOG_PROFILE      - Which log types to forward (default: all)
#                      - all: Forward all log types
#                      - security: suricata, mitm, microseg, fqdn, cmd
#                      - networking: tunnel_status
#
# JSON Format: Array of log event objects per POST
# See: https://docs.dynatrace.com/docs/dynatrace-api/environment-api/log-monitoring-v2/post-ingest-logs

# Build Dynatrace log payload for tunnel status events
filter {
    if "tunnel_status" in [tags] {
        ruby {
            id => "dynatrace-build-tunnel-status-log"
            code => '
                src = event.get("src_gw") || ""
                dst = event.get("dst_gw") || ""
                new_state = event.get("new_state") || ""
                old_state = event.get("old_state") || ""
                source = ENV.fetch("DT_LOG_SOURCE", ENV.fetch("DT_METRIC_SOURCE", "aviatrix"))

                # Parse "k8s-transit(AWS us-east-2)" into name, cloud, region
                src_match = src.match(/^([^(]+)\((\S+)\s+([^)]+)\)/)
                dst_match = dst.match(/^([^(]+)\((\S+)\s+([^)]+)\)/)

                severity = (new_state.downcase == "down") ? "WARN" : "INFORMATIONAL"
                content = "Tunnel #{new_state}: #{src} -> #{dst}"

                ts = event.get("@timestamp")
                timestamp = ts ? ts.to_iso8601 : Time.now.utc.iso8601(3)

                log_event = {
                    "timestamp" => timestamp,
                    "severity" => severity,
                    "content" => content,
                    "log.source" => source,
                    "aviatrix.event.type" => "TunnelStatus",
                    "aviatrix.tunnel.src_gw" => src_match ? src_match[1].strip : src,
                    "aviatrix.tunnel.src_cloud" => src_match ? src_match[2].downcase : "",
                    "aviatrix.tunnel.src_region" => src_match ? src_match[3] : "",
                    "aviatrix.tunnel.dst_gw" => dst_match ? dst_match[1].strip : dst,
                    "aviatrix.tunnel.dst_cloud" => dst_match ? dst_match[2].downcase : "",
                    "aviatrix.tunnel.dst_region" => dst_match ? dst_match[3] : "",
                    "aviatrix.tunnel.new_state" => new_state,
                    "aviatrix.tunnel.old_state" => old_state
                }

                if src_match
                    log_event["cloud.provider"] = src_match[2].downcase
                    log_event["cloud.region"] = src_match[3]
                end

                event.set("[@metadata][dt_log_payload]", "[" + log_event.to_json + "]")
            '
        }
    }
}

# Build Dynatrace log payload for FQDN firewall events
filter {
    if "fqdn" in [tags] {
        ruby {
            id => "dynatrace-build-fqdn-log"
            code => '
                gateway = event.get("gateway") || ""
                sip = event.get("sip") || ""
                dip = event.get("dip") || ""
                hostname = event.get("hostname") || ""
                state = event.get("state") || ""
                drop = event.get("drop") || ""
                rule = event.get("rule") || ""
                source = ENV.fetch("DT_LOG_SOURCE", ENV.fetch("DT_METRIC_SOURCE", "aviatrix"))

                is_deny = (state.downcase == "blocked" || state.downcase == "denied" ||
                           drop.downcase == "true" || drop.downcase == "yes")
                severity = is_deny ? "WARN" : "INFORMATIONAL"
                action_word = is_deny ? "Deny" : "Allow"
                content = "FQDN #{action_word}: #{sip} -> #{hostname} (#{dip}) on #{gateway}"

                ts = event.get("@timestamp")
                timestamp = ts ? ts.to_iso8601 : Time.now.utc.iso8601(3)

                log_event = {
                    "timestamp" => timestamp,
                    "severity" => severity,
                    "content" => content,
                    "log.source" => source,
                    "aviatrix.event.type" => "FQDNFilter",
                    "aviatrix.firewall.gateway" => gateway,
                    "aviatrix.firewall.src_ip" => sip,
                    "aviatrix.firewall.dst_ip" => dip,
                    "aviatrix.firewall.hostname" => hostname,
                    "aviatrix.firewall.state" => state,
                    "aviatrix.firewall.rule" => rule
                }
                log_event["aviatrix.firewall.drop_reason"] = drop unless drop.empty?

                event.set("[@metadata][dt_log_payload]", "[" + log_event.to_json + "]")
            '
        }
    }
}

# Build Dynatrace log payload for controller CMD/API events
filter {
    if "cmd" in [tags] {
        ruby {
            id => "dynatrace-build-cmd-log"
            code => '
                action = event.get("action") || ""
                username = event.get("username") || ""
                result = event.get("result") || ""
                reason = event.get("reason") || ""
                args = event.get("args") || ""
                source = ENV.fetch("DT_LOG_SOURCE", ENV.fetch("DT_METRIC_SOURCE", "aviatrix"))

                severity = (result.downcase != "success") ? "WARN" : "INFORMATIONAL"
                content = "Controller API: #{action}"
                content += " by #{username}" unless username.empty?
                content += " - #{result}"

                ts = event.get("@timestamp")
                timestamp = ts ? ts.to_iso8601 : Time.now.utc.iso8601(3)

                log_event = {
                    "timestamp" => timestamp,
                    "severity" => severity,
                    "content" => content,
                    "log.source" => source,
                    "aviatrix.event.type" => "ControllerAudit",
                    "aviatrix.controller.action" => action,
                    "aviatrix.controller.result" => result,
                    "aviatrix.controller.username" => username
                }
                log_event["aviatrix.controller.reason"] = reason unless reason.empty?
                log_event["aviatrix.controller.args"] = args unless args.empty?

                gw_host = event.get("gw_hostname")
                log_event["aviatrix.controller.host"] = gw_host if gw_host

                event.set("[@metadata][dt_log_payload]", "[" + log_event.to_json + "]")
            '
        }
    }
}

# Build Dynatrace log payload for L4 microseg (DCF) events
filter {
    if "microseg" in [tags] {
        ruby {
            id => "dynatrace-build-microseg-log"
            code => '
                src_ip = event.get("src_ip") || ""
                dst_ip = event.get("dst_ip") || ""
                src_port = event.get("src_port") || ""
                dst_port = event.get("dst_port") || ""
                proto = event.get("proto") || ""
                action = event.get("action") || ""
                enforced = event.get("enforced") || ""
                uuid = event.get("uuid") || ""
                gw_hostname = event.get("gw_hostname") || ""
                source = ENV.fetch("DT_LOG_SOURCE", ENV.fetch("DT_METRIC_SOURCE", "aviatrix"))

                severity = (action.upcase == "DENY" || action.upcase == "DROP") ? "WARN" : "INFORMATIONAL"
                action_word = (action.upcase == "DENY" || action.upcase == "DROP") ? "Deny" : "Allow"
                content = "L4 DCF #{action_word}: #{src_ip}:#{src_port} -> #{dst_ip}:#{dst_port} #{proto}"

                ts = event.get("@timestamp")
                timestamp = ts ? ts.to_iso8601 : Time.now.utc.iso8601(3)

                log_event = {
                    "timestamp" => timestamp,
                    "severity" => severity,
                    "content" => content,
                    "log.source" => source,
                    "aviatrix.event.type" => "DCFPolicyEvent",
                    "aviatrix.dcf.layer" => "L4",
                    "aviatrix.dcf.action" => action,
                    "aviatrix.dcf.enforced" => enforced,
                    "aviatrix.dcf.policy_uuid" => uuid,
                    "aviatrix.dcf.src_ip" => src_ip,
                    "aviatrix.dcf.dst_ip" => dst_ip,
                    "aviatrix.dcf.src_port" => src_port,
                    "aviatrix.dcf.dst_port" => dst_port,
                    "aviatrix.dcf.protocol" => proto,
                    "aviatrix.dcf.gateway" => gw_hostname
                }

                # Add session fields if present (8.2+)
                session_id = event.get("session_id")
                if session_id
                    log_event["aviatrix.dcf.session_id"] = session_id
                    %w[session_event session_end_reason session_pkt_cnt session_byte_cnt session_dur].each do |f|
                        val = event.get(f)
                        log_event["aviatrix.dcf.#{f}"] = val if val
                    end
                end

                event.set("[@metadata][dt_log_payload]", "[" + log_event.to_json + "]")
            '
        }
    }
}

# Build Dynatrace log payload for L7 MITM/DCF events
filter {
    if "mitm" in [tags] {
        ruby {
            id => "dynatrace-build-mitm-log"
            code => '
                # Helper to get field value, treating unresolved %{...} references as empty
                resolve = lambda { |v| (v.nil? || v.to_s.include?("%{")) ? "" : v.to_s }

                src_ip = resolve.call(event.get("src_ip"))
                dst_ip = resolve.call(event.get("dst_ip"))
                src_port = event.get("src_port") || ""
                dst_port = event.get("dst_port") || ""
                action = resolve.call(event.get("action"))
                enforced = event.get("enforced")
                enforced = "" if enforced.nil?
                uuid = resolve.call(event.get("uuid"))
                gw_hostname = resolve.call(event.get("gw_hostname"))
                sni = resolve.call(event.get("mitm_sni_hostname"))
                url_parts = resolve.call(event.get("mitm_url_parts"))
                decrypted_by = resolve.call(event.get("mitm_decrypted_by"))
                source = ENV.fetch("DT_LOG_SOURCE", ENV.fetch("DT_METRIC_SOURCE", "aviatrix"))

                severity = (action.upcase == "DENY" || action.upcase == "DROP") ? "WARN" : "INFORMATIONAL"
                action_word = (action.upcase == "DENY" || action.upcase == "DROP") ? "Deny" : "Allow"
                target = sni.empty? ? "#{dst_ip}:#{dst_port}" : sni
                content = "L7 DCF #{action_word}: #{src_ip} -> #{target}"

                ts = event.get("@timestamp")
                timestamp = ts ? ts.to_iso8601 : Time.now.utc.iso8601(3)

                log_event = {
                    "timestamp" => timestamp,
                    "severity" => severity,
                    "content" => content,
                    "log.source" => source,
                    "aviatrix.event.type" => "WebInspection",
                    "aviatrix.dcf.layer" => "L7",
                    "aviatrix.dcf.action" => action,
                    "aviatrix.dcf.enforced" => enforced,
                    "aviatrix.dcf.policy_uuid" => uuid,
                    "aviatrix.dcf.src_ip" => src_ip,
                    "aviatrix.dcf.dst_ip" => dst_ip,
                    "aviatrix.dcf.src_port" => src_port,
                    "aviatrix.dcf.dst_port" => dst_port,
                    "aviatrix.dcf.protocol" => "TCP",
                    "aviatrix.dcf.gateway" => gw_hostname
                }
                log_event["aviatrix.dcf.sni_hostname"] = sni unless sni.empty?
                log_event["aviatrix.dcf.url"] = url_parts unless url_parts.empty?
                log_event["aviatrix.dcf.decrypted_by"] = decrypted_by unless decrypted_by.empty?

                event.set("[@metadata][dt_log_payload]", "[" + log_event.to_json + "]")
            '
        }
    }
}

# Build Dynatrace log payload for Suricata IDS events
filter {
    if "suricata" in [tags] and [suricataDataJson] {
        ruby {
            id => "dynatrace-build-suricata-log"
            code => '
                data = event.get("suricataDataJson")
                next unless data.is_a?(Hash)

                gw_hostname = event.get("gw_hostname") || ""
                source = ENV.fetch("DT_LOG_SOURCE", ENV.fetch("DT_METRIC_SOURCE", "aviatrix"))

                # Extract alert fields
                alert = data["alert"] || {}
                signature = alert["signature"] || "Unknown"
                alert_severity = (alert["severity"] || 3).to_i
                category = alert["category"] || ""
                signature_id = alert["signature_id"]
                gid = alert["gid"]
                rev = alert["rev"]

                src_ip = data["src_ip"] || ""
                dst_ip = data["dest_ip"] || ""
                src_port = (data["src_port"] || "").to_s
                dst_port = (data["dest_port"] || "").to_s
                proto = data["proto"] || ""
                event_type = data["event_type"] || ""

                # Map Suricata severity to Dynatrace severity
                # Suricata: 1=high, 2=medium, 3=low
                case alert_severity
                when 1
                    severity = "ERROR"
                when 2
                    severity = "WARN"
                else
                    severity = "INFORMATIONAL"
                end

                # Build content based on event type
                if event_type == "alert" && !signature.empty?
                    content = "IDS Alert: #{signature}"
                    content += " (#{category})" unless category.empty?
                    content += " #{src_ip}:#{src_port} -> #{dst_ip}:#{dst_port}"
                else
                    content = "IDS #{event_type}: #{src_ip}:#{src_port} -> #{dst_ip}:#{dst_port} #{proto}"
                    severity = "INFORMATIONAL"
                end

                # Use Suricata own timestamp if available (more precise)
                suri_ts = data["timestamp"]
                if suri_ts
                    timestamp = suri_ts
                else
                    ts = event.get("@timestamp")
                    timestamp = ts ? ts.to_iso8601 : Time.now.utc.iso8601(3)
                end

                log_event = {
                    "timestamp" => timestamp,
                    "severity" => severity,
                    "content" => content,
                    "log.source" => source,
                    "aviatrix.event.type" => "IDSAlert",
                    "aviatrix.ids.event_type" => event_type,
                    "aviatrix.ids.src_ip" => src_ip,
                    "aviatrix.ids.dst_ip" => dst_ip,
                    "aviatrix.ids.src_port" => src_port,
                    "aviatrix.ids.dst_port" => dst_port,
                    "aviatrix.ids.protocol" => proto,
                    "aviatrix.ids.gateway" => gw_hostname
                }

                # Alert-specific fields
                if event_type == "alert"
                    log_event["aviatrix.ids.signature"] = signature
                    log_event["aviatrix.ids.severity"] = alert_severity
                    log_event["aviatrix.ids.category"] = category unless category.empty?
                    log_event["aviatrix.ids.signature_id"] = signature_id if signature_id
                    log_event["aviatrix.ids.gid"] = gid if gid
                    log_event["aviatrix.ids.rev"] = rev if rev
                end

                # Flow fields
                flow = data["flow"] || {}
                unless flow.empty?
                    log_event["aviatrix.ids.flow.pkts_toserver"] = flow["pkts_toserver"] if flow["pkts_toserver"]
                    log_event["aviatrix.ids.flow.pkts_toclient"] = flow["pkts_toclient"] if flow["pkts_toclient"]
                    log_event["aviatrix.ids.flow.bytes_toserver"] = flow["bytes_toserver"] if flow["bytes_toserver"]
                    log_event["aviatrix.ids.flow.bytes_toclient"] = flow["bytes_toclient"] if flow["bytes_toclient"]
                end

                # HTTP fields
                http = data["http"] || {}
                unless http.empty?
                    log_event["aviatrix.ids.http.hostname"] = http["hostname"] if http["hostname"]
                    log_event["aviatrix.ids.http.url"] = http["url"] if http["url"]
                    log_event["aviatrix.ids.http.method"] = http["http_method"] if http["http_method"]
                    log_event["aviatrix.ids.http.status"] = http["status"] if http["status"]
                end

                # TLS fields
                tls = data["tls"] || {}
                unless tls.empty?
                    log_event["aviatrix.ids.tls.sni"] = tls["sni"] if tls["sni"]
                    log_event["aviatrix.ids.tls.subject"] = tls["subject"] if tls["subject"]
                    if tls["ja3"].is_a?(Hash) && tls["ja3"]["hash"]
                        log_event["aviatrix.ids.tls.ja3_hash"] = tls["ja3"]["hash"]
                    end
                end

                event.set("[@metadata][dt_log_payload]", "[" + log_event.to_json + "]")
            '
        }
    }
}

output {
    # Send event logs to Dynatrace Logs Ingest API v2
    if [@metadata][dt_log_payload] {
        # Security log types (suricata, mitm, microseg, fqdn, cmd)
        if (("suricata" in [tags] or "mitm" in [tags] or "microseg" in [tags] or "fqdn" in [tags] or "cmd" in [tags]) and ("${LOG_PROFILE:all}" == "all" or "${LOG_PROFILE:all}" == "security"))
           or ("tunnel_status" in [tags] and ("${LOG_PROFILE:all}" == "all" or "${LOG_PROFILE:all}" == "networking")) {
            http {
                id => "dynatrace-logs"
                http_method => "post"
                url => "${DT_LOGS_URL}"
                headers => {
                    "Authorization" => "Bearer ${DT_LOGS_TOKEN}"
                }
                content_type => "application/json; charset=utf-8"
                format => "message"
                message => "%{[@metadata][dt_log_payload]}"
                pool_max => 10
                pool_max_per_route => 5
                socket_timeout => 30
            }
        }
    }
}
