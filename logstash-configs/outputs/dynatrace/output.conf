# Dynatrace Combined Output — Metrics + Logs
# Sends gateway metrics (MINT) to /api/v2/metrics/ingest
# Sends event logs (JSON) to /api/v2/logs/ingest
#
# Environment Variables:
#   DT_METRICS_URL     - Dynatrace metrics ingest URL
#   DT_API_TOKEN       - API token with "metrics.ingest" scope
#   DT_METRIC_SOURCE   - Source dimension for metrics (default: "aviatrix")
#   DT_LOGS_URL        - Dynatrace logs ingest URL
#   DT_LOGS_TOKEN      - API token with "logs.ingest" scope
#   DT_LOG_SOURCE      - log.source attribute for logs (default: falls back to DT_METRIC_SOURCE, then "aviatrix")
#   LOG_PROFILE        - Which log types to forward (default: all)
#                        - all: Forward all metrics and logs
#                        - security: suricata, mitm, microseg, fqdn, cmd
#                        - networking: gw_net_stats, gw_sys_stats, tunnel_status

# ===========================================================================
# METRICS — MINT Protocol Payload Builders
# ===========================================================================

# Build MINT payload for gateway system stats
filter {
    if "gw_sys_stats" in [tags] {
        ruby {
            id => "dynatrace-build-sys-stats-mint"
            code => '
                gw = event.get("gateway") || "unknown"
                ali = event.get("alias") || gw
                src = ENV.fetch("DT_METRIC_SOURCE", "aviatrix")
                ts = (event.get("@timestamp").to_f * 1000).to_i

                # Escape dimension values for MINT protocol
                esc = lambda { |v| v.to_s.gsub("\\", "\\\\").gsub("\"", "\\\"") }

                dims = "gateway=\"#{esc.call(gw)}\",alias=\"#{esc.call(ali)}\",source=\"#{esc.call(src)}\""
                lines = []

                # CPU metrics
                cpu_idle = event.get("cpu_idle")
                if cpu_idle
                    idle_f = cpu_idle.to_f
                    lines << "aviatrix.gateway.cpu.idle,#{dims} gauge,#{idle_f} #{ts}"
                    lines << "aviatrix.gateway.cpu.usage,#{dims} gauge,#{(100 - idle_f).round(2)} #{ts}"
                end

                # Memory metrics (raw values are kB, convert to bytes)
                mem_avail = event.get("memory_available")
                mem_total = event.get("memory_total")
                mem_free  = event.get("memory_free")
                if mem_avail && mem_total
                    avail_f = mem_avail.to_f
                    total_f = mem_total.to_f
                    free_f  = mem_free.to_f

                    lines << "aviatrix.gateway.memory.avail,#{dims} gauge,#{(avail_f * 1024).to_i} #{ts}"
                    lines << "aviatrix.gateway.memory.total,#{dims} gauge,#{(total_f * 1024).to_i} #{ts}"
                    lines << "aviatrix.gateway.memory.free,#{dims} gauge,#{(free_f * 1024).to_i} #{ts}"
                    lines << "aviatrix.gateway.memory.used,#{dims} gauge,#{((total_f - avail_f) * 1024).to_i} #{ts}"
                    if total_f > 0
                        lines << "aviatrix.gateway.memory.usage,#{dims} gauge,#{((1.0 - avail_f / total_f) * 100).round(2)} #{ts}"
                    end
                end

                # Disk metrics (raw values are kB, convert to bytes)
                disk_total = event.get("disk_total")
                disk_free  = event.get("disk_free")
                if disk_total && disk_free
                    dt_f = disk_total.to_f
                    df_f = disk_free.to_f

                    lines << "aviatrix.gateway.disk.avail,#{dims} gauge,#{(df_f * 1024).to_i} #{ts}"
                    lines << "aviatrix.gateway.disk.total,#{dims} gauge,#{(dt_f * 1024).to_i} #{ts}"
                    lines << "aviatrix.gateway.disk.used,#{dims} gauge,#{((dt_f - df_f) * 1024).to_i} #{ts}"
                    if dt_f > 0
                        lines << "aviatrix.gateway.disk.used.percent,#{dims} gauge,#{((1.0 - df_f / dt_f) * 100).round(2)} #{ts}"
                    end
                end

                # Per-core CPU metrics (from filter 17 cpu_cores_parsed)
                cpu_cores_parsed = event.get("cpu_cores_parsed")
                if cpu_cores_parsed.is_a?(Array)
                    cpu_cores_parsed.each do |core|
                        core_name = core["name"]
                        next unless core_name
                        core_dim = core_name == "-1" ? "aggregate" : core_name
                        cdims = "#{dims},core=\"#{esc.call(core_dim)}\""

                        if core["busy_avg"]
                            busy = core["busy_avg"].to_f
                            lines << "aviatrix.gateway.cpu.idle,#{cdims} gauge,#{(100 - busy).round(2)} #{ts}"
                            lines << "aviatrix.gateway.cpu.usage,#{cdims} gauge,#{busy} #{ts}"
                        end
                    end
                end

                event.set("[@metadata][dynatrace_mint_payload]", lines.join("\n")) unless lines.empty?
            '
        }
    }
}

# Build MINT payload for gateway network stats
filter {
    if "gw_net_stats" in [tags] {
        ruby {
            id => "dynatrace-build-net-stats-mint"
            code => '
                gw = event.get("gateway") || "unknown"
                ali = event.get("alias") || gw
                src = ENV.fetch("DT_METRIC_SOURCE", "aviatrix")
                ts = (event.get("@timestamp").to_f * 1000).to_i
                iface = event.get("interface") || "unknown"
                pub_ip = event.get("public_ip")
                priv_ip = event.get("private_ip") || "unknown"

                esc = lambda { |v| v.to_s.gsub("\\", "\\\\").gsub("\"", "\\\"") }

                dims = "gateway=\"#{esc.call(gw)}\",alias=\"#{esc.call(ali)}\",source=\"#{esc.call(src)}\""
                dims += ",interface=\"#{esc.call(iface)}\""
                dims += ",public_ip=\"#{esc.call(pub_ip)}\"" if pub_ip && pub_ip.to_s != ""
                dims += ",private_ip=\"#{esc.call(priv_ip)}\""

                # Parse human-readable byte strings to numeric bytes
                # Handles: "54.07Kb" "2.49GB" "510.30MB" "3.73" "13.45KB"
                parse_to_bytes = lambda do |val|
                    return nil unless val
                    s = val.to_s.strip
                    return nil if s.empty?
                    m = s.match(/\A([\d.]+)\s*(KB|MB|GB|TB|Kb|Mb|Gb|B)?\z/i)
                    return s.to_f unless m
                    num = m[1].to_f
                    unit = m[2]
                    return num unless unit
                    case unit
                    when "B"
                        num
                    when "Kb", "KB", "kb"
                        num * 1024
                    when "Mb", "MB", "mb"
                        num * 1024 * 1024
                    when "Gb", "GB", "gb"
                        num * 1024 * 1024 * 1024
                    when "Tb", "TB", "tb"
                        num * 1024 * 1024 * 1024 * 1024
                    else
                        num
                    end
                end

                lines = []

                # Rate metrics (from raw strings preserved in [@metadata] by filter 94)
                rx_rate = parse_to_bytes.call(event.get("[@metadata][raw_total_rx_rate]"))
                tx_rate = parse_to_bytes.call(event.get("[@metadata][raw_total_tx_rate]"))
                rxtx_rate = parse_to_bytes.call(event.get("[@metadata][raw_total_rx_tx_rate]"))

                lines << "aviatrix.gateway.net.bytes_rx,#{dims} gauge,#{rx_rate.round(2)} #{ts}" if rx_rate
                lines << "aviatrix.gateway.net.bytes_tx,#{dims} gauge,#{tx_rate.round(2)} #{ts}" if tx_rate
                lines << "aviatrix.gateway.net.bytes_total_rate,#{dims} gauge,#{rxtx_rate.round(2)} #{ts}" if rxtx_rate

                # Cumulative metrics (from raw strings preserved in [@metadata] by filter 94)
                rx_cum = parse_to_bytes.call(event.get("[@metadata][raw_total_rx_cum]"))
                tx_cum = parse_to_bytes.call(event.get("[@metadata][raw_total_tx_cum]"))
                rxtx_cum = parse_to_bytes.call(event.get("[@metadata][raw_total_rx_tx_cum]"))

                lines << "aviatrix.gateway.net.rx_cumulative,#{dims} gauge,#{rx_cum.round(2)} #{ts}" if rx_cum
                lines << "aviatrix.gateway.net.tx_cumulative,#{dims} gauge,#{tx_cum.round(2)} #{ts}" if tx_cum
                lines << "aviatrix.gateway.net.rx_tx_cumulative,#{dims} gauge,#{rxtx_cum.round(2)} #{ts}" if rxtx_cum

                # Conntrack gauge metrics
                ct_count = event.get("conntrack_count")
                lines << "aviatrix.gateway.net.conntrack.count,#{dims} gauge,#{ct_count.to_i} #{ts}" if ct_count && ct_count.to_s != ""

                ct_avail = event.get("conntrack_allowance_available")
                lines << "aviatrix.gateway.net.conntrack.avail,#{dims} gauge,#{ct_avail.to_i} #{ts}" if ct_avail && ct_avail.to_s != ""

                ct_usage = event.get("conntrack_usage_rate")
                if ct_usage && ct_usage.to_s != ""
                    lines << "aviatrix.gateway.net.conntrack.usage,#{dims} gauge,#{(ct_usage.to_f * 100).round(2)} #{ts}"
                end

                # Limit-exceeded count metrics (delta counters)
                %w[conntrack_limit_exceeded bw_in_limit_exceeded bw_out_limit_exceeded pps_limit_exceeded linklocal_limit_exceeded].each do |field|
                    val = event.get(field)
                    if val && val.to_s != ""
                        lines << "aviatrix.gateway.net.#{field},#{dims} count,delta=#{val.to_i} #{ts}"
                    end
                end

                event.set("[@metadata][dynatrace_mint_payload]", lines.join("\n")) unless lines.empty?
            '
        }
    }
}

# ===========================================================================
# LOGS — JSON Payload Builders
# ===========================================================================

# Build Dynatrace log payload for tunnel status events
filter {
    if "tunnel_status" in [tags] {
        ruby {
            id => "dynatrace-build-tunnel-status-log"
            code => '
                src = event.get("src_gw") || ""
                dst = event.get("dst_gw") || ""
                new_state = event.get("new_state") || ""
                old_state = event.get("old_state") || ""
                source = ENV.fetch("DT_LOG_SOURCE", ENV.fetch("DT_METRIC_SOURCE", "aviatrix"))

                # Parse "k8s-transit(AWS us-east-2)" into name, cloud, region
                src_match = src.match(/^([^(]+)\((\S+)\s+([^)]+)\)/)
                dst_match = dst.match(/^([^(]+)\((\S+)\s+([^)]+)\)/)

                severity = (new_state.downcase == "down") ? "WARN" : "INFORMATIONAL"
                content = "Tunnel #{new_state}: #{src} -> #{dst}"

                ts = event.get("@timestamp")
                timestamp = ts ? ts.to_iso8601 : Time.now.utc.iso8601(3)

                log_event = {
                    "timestamp" => timestamp,
                    "severity" => severity,
                    "content" => content,
                    "log.source" => source,
                    "aviatrix.event.type" => "TunnelStatus",
                    "aviatrix.tunnel.src_gw" => src_match ? src_match[1].strip : src,
                    "aviatrix.tunnel.src_cloud" => src_match ? src_match[2].downcase : "",
                    "aviatrix.tunnel.src_region" => src_match ? src_match[3] : "",
                    "aviatrix.tunnel.dst_gw" => dst_match ? dst_match[1].strip : dst,
                    "aviatrix.tunnel.dst_cloud" => dst_match ? dst_match[2].downcase : "",
                    "aviatrix.tunnel.dst_region" => dst_match ? dst_match[3] : "",
                    "aviatrix.tunnel.new_state" => new_state,
                    "aviatrix.tunnel.old_state" => old_state
                }

                if src_match
                    log_event["cloud.provider"] = src_match[2].downcase
                    log_event["cloud.region"] = src_match[3]
                end

                event.set("[@metadata][dt_log_payload]", "[" + log_event.to_json + "]")
            '
        }
    }
}

# Build Dynatrace log payload for FQDN firewall events
filter {
    if "fqdn" in [tags] {
        ruby {
            id => "dynatrace-build-fqdn-log"
            code => '
                gateway = event.get("gateway") || ""
                sip = event.get("sip") || ""
                dip = event.get("dip") || ""
                hostname = event.get("hostname") || ""
                state = event.get("state") || ""
                drop = event.get("drop") || ""
                rule = event.get("rule") || ""
                source = ENV.fetch("DT_LOG_SOURCE", ENV.fetch("DT_METRIC_SOURCE", "aviatrix"))

                is_deny = (state.downcase == "blocked" || state.downcase == "denied" ||
                           drop.downcase == "true" || drop.downcase == "yes")
                severity = is_deny ? "WARN" : "INFORMATIONAL"
                action_word = is_deny ? "Deny" : "Allow"
                content = "FQDN #{action_word}: #{sip} -> #{hostname} (#{dip}) on #{gateway}"

                ts = event.get("@timestamp")
                timestamp = ts ? ts.to_iso8601 : Time.now.utc.iso8601(3)

                log_event = {
                    "timestamp" => timestamp,
                    "severity" => severity,
                    "content" => content,
                    "log.source" => source,
                    "aviatrix.event.type" => "FQDNFilter",
                    "aviatrix.firewall.gateway" => gateway,
                    "aviatrix.firewall.src_ip" => sip,
                    "aviatrix.firewall.dst_ip" => dip,
                    "aviatrix.firewall.hostname" => hostname,
                    "aviatrix.firewall.state" => state,
                    "aviatrix.firewall.rule" => rule
                }
                log_event["aviatrix.firewall.drop_reason"] = drop unless drop.empty?

                event.set("[@metadata][dt_log_payload]", "[" + log_event.to_json + "]")
            '
        }
    }
}

# Build Dynatrace log payload for controller CMD/API events
filter {
    if "cmd" in [tags] {
        ruby {
            id => "dynatrace-build-cmd-log"
            code => '
                action = event.get("action") || ""
                username = event.get("username") || ""
                result = event.get("result") || ""
                reason = event.get("reason") || ""
                args = event.get("args") || ""
                source = ENV.fetch("DT_LOG_SOURCE", ENV.fetch("DT_METRIC_SOURCE", "aviatrix"))

                severity = (result.downcase != "success") ? "WARN" : "INFORMATIONAL"
                content = "Controller API: #{action}"
                content += " by #{username}" unless username.empty?
                content += " - #{result}"

                ts = event.get("@timestamp")
                timestamp = ts ? ts.to_iso8601 : Time.now.utc.iso8601(3)

                log_event = {
                    "timestamp" => timestamp,
                    "severity" => severity,
                    "content" => content,
                    "log.source" => source,
                    "aviatrix.event.type" => "ControllerAudit",
                    "aviatrix.controller.action" => action,
                    "aviatrix.controller.result" => result,
                    "aviatrix.controller.username" => username
                }
                log_event["aviatrix.controller.reason"] = reason unless reason.empty?
                log_event["aviatrix.controller.args"] = args unless args.empty?

                gw_host = event.get("gw_hostname")
                log_event["aviatrix.controller.host"] = gw_host if gw_host

                event.set("[@metadata][dt_log_payload]", "[" + log_event.to_json + "]")
            '
        }
    }
}

# Build Dynatrace log payload for L4 microseg (DCF) events
filter {
    if "microseg" in [tags] {
        ruby {
            id => "dynatrace-build-microseg-log"
            code => '
                src_ip = event.get("src_ip") || ""
                dst_ip = event.get("dst_ip") || ""
                src_port = event.get("src_port") || ""
                dst_port = event.get("dst_port") || ""
                proto = event.get("proto") || ""
                action = event.get("action") || ""
                enforced = event.get("enforced") || ""
                uuid = event.get("uuid") || ""
                gw_hostname = event.get("gw_hostname") || ""
                source = ENV.fetch("DT_LOG_SOURCE", ENV.fetch("DT_METRIC_SOURCE", "aviatrix"))

                severity = (action.upcase == "DENY" || action.upcase == "DROP") ? "WARN" : "INFORMATIONAL"
                action_word = (action.upcase == "DENY" || action.upcase == "DROP") ? "Deny" : "Allow"
                content = "L4 DCF #{action_word}: #{src_ip}:#{src_port} -> #{dst_ip}:#{dst_port} #{proto}"

                ts = event.get("@timestamp")
                timestamp = ts ? ts.to_iso8601 : Time.now.utc.iso8601(3)

                log_event = {
                    "timestamp" => timestamp,
                    "severity" => severity,
                    "content" => content,
                    "log.source" => source,
                    "aviatrix.event.type" => "DCFPolicyEvent",
                    "aviatrix.dcf.layer" => "L4",
                    "aviatrix.dcf.action" => action,
                    "aviatrix.dcf.enforced" => enforced,
                    "aviatrix.dcf.policy_uuid" => uuid,
                    "aviatrix.dcf.src_ip" => src_ip,
                    "aviatrix.dcf.dst_ip" => dst_ip,
                    "aviatrix.dcf.src_port" => src_port,
                    "aviatrix.dcf.dst_port" => dst_port,
                    "aviatrix.dcf.protocol" => proto,
                    "aviatrix.dcf.gateway" => gw_hostname
                }

                # Add session fields if present (8.2+)
                session_id = event.get("session_id")
                if session_id
                    log_event["aviatrix.dcf.session_id"] = session_id
                    %w[session_event session_end_reason session_pkt_cnt session_byte_cnt session_dur].each do |f|
                        val = event.get(f)
                        log_event["aviatrix.dcf.#{f}"] = val if val
                    end
                end

                event.set("[@metadata][dt_log_payload]", "[" + log_event.to_json + "]")
            '
        }
    }
}

# Build Dynatrace log payload for L7 MITM/DCF events
filter {
    if "mitm" in [tags] {
        ruby {
            id => "dynatrace-build-mitm-log"
            code => '
                # Helper to get field value, treating unresolved %{...} references as empty
                resolve = lambda { |v| (v.nil? || v.to_s.include?("%{")) ? "" : v.to_s }

                src_ip = resolve.call(event.get("src_ip"))
                dst_ip = resolve.call(event.get("dst_ip"))
                src_port = event.get("src_port") || ""
                dst_port = event.get("dst_port") || ""
                action = resolve.call(event.get("action"))
                enforced = event.get("enforced")
                enforced = "" if enforced.nil?
                uuid = resolve.call(event.get("uuid"))
                gw_hostname = resolve.call(event.get("gw_hostname"))
                sni = resolve.call(event.get("mitm_sni_hostname"))
                url_parts = resolve.call(event.get("mitm_url_parts"))
                decrypted_by = resolve.call(event.get("mitm_decrypted_by"))
                source = ENV.fetch("DT_LOG_SOURCE", ENV.fetch("DT_METRIC_SOURCE", "aviatrix"))

                severity = (action.upcase == "DENY" || action.upcase == "DROP") ? "WARN" : "INFORMATIONAL"
                action_word = (action.upcase == "DENY" || action.upcase == "DROP") ? "Deny" : "Allow"
                target = sni.empty? ? "#{dst_ip}:#{dst_port}" : sni
                content = "L7 DCF #{action_word}: #{src_ip} -> #{target}"

                ts = event.get("@timestamp")
                timestamp = ts ? ts.to_iso8601 : Time.now.utc.iso8601(3)

                log_event = {
                    "timestamp" => timestamp,
                    "severity" => severity,
                    "content" => content,
                    "log.source" => source,
                    "aviatrix.event.type" => "WebInspection",
                    "aviatrix.dcf.layer" => "L7",
                    "aviatrix.dcf.action" => action,
                    "aviatrix.dcf.enforced" => enforced,
                    "aviatrix.dcf.policy_uuid" => uuid,
                    "aviatrix.dcf.src_ip" => src_ip,
                    "aviatrix.dcf.dst_ip" => dst_ip,
                    "aviatrix.dcf.src_port" => src_port,
                    "aviatrix.dcf.dst_port" => dst_port,
                    "aviatrix.dcf.protocol" => "TCP",
                    "aviatrix.dcf.gateway" => gw_hostname
                }
                log_event["aviatrix.dcf.sni_hostname"] = sni unless sni.empty?
                log_event["aviatrix.dcf.url"] = url_parts unless url_parts.empty?
                log_event["aviatrix.dcf.decrypted_by"] = decrypted_by unless decrypted_by.empty?

                event.set("[@metadata][dt_log_payload]", "[" + log_event.to_json + "]")
            '
        }
    }
}

# Build Dynatrace log payload for Suricata IDS events
filter {
    if "suricata" in [tags] and [suricataDataJson] {
        ruby {
            id => "dynatrace-build-suricata-log"
            code => '
                data = event.get("suricataDataJson")
                next unless data.is_a?(Hash)

                gw_hostname = event.get("gw_hostname") || ""
                source = ENV.fetch("DT_LOG_SOURCE", ENV.fetch("DT_METRIC_SOURCE", "aviatrix"))

                # Extract alert fields
                alert = data["alert"] || {}
                signature = alert["signature"] || "Unknown"
                alert_severity = (alert["severity"] || 3).to_i
                category = alert["category"] || ""
                signature_id = alert["signature_id"]
                gid = alert["gid"]
                rev = alert["rev"]

                src_ip = data["src_ip"] || ""
                dst_ip = data["dest_ip"] || ""
                src_port = (data["src_port"] || "").to_s
                dst_port = (data["dest_port"] || "").to_s
                proto = data["proto"] || ""
                event_type = data["event_type"] || ""

                # Map Suricata severity to Dynatrace severity
                # Suricata: 1=high, 2=medium, 3=low
                case alert_severity
                when 1
                    severity = "ERROR"
                when 2
                    severity = "WARN"
                else
                    severity = "INFORMATIONAL"
                end

                # Build content based on event type
                if event_type == "alert" && !signature.empty?
                    content = "IDS Alert: #{signature}"
                    content += " (#{category})" unless category.empty?
                    content += " #{src_ip}:#{src_port} -> #{dst_ip}:#{dst_port}"
                else
                    content = "IDS #{event_type}: #{src_ip}:#{src_port} -> #{dst_ip}:#{dst_port} #{proto}"
                    severity = "INFORMATIONAL"
                end

                # Use Suricata own timestamp if available (more precise)
                suri_ts = data["timestamp"]
                if suri_ts
                    timestamp = suri_ts
                else
                    ts = event.get("@timestamp")
                    timestamp = ts ? ts.to_iso8601 : Time.now.utc.iso8601(3)
                end

                log_event = {
                    "timestamp" => timestamp,
                    "severity" => severity,
                    "content" => content,
                    "log.source" => source,
                    "aviatrix.event.type" => "IDSAlert",
                    "aviatrix.ids.event_type" => event_type,
                    "aviatrix.ids.src_ip" => src_ip,
                    "aviatrix.ids.dst_ip" => dst_ip,
                    "aviatrix.ids.src_port" => src_port,
                    "aviatrix.ids.dst_port" => dst_port,
                    "aviatrix.ids.protocol" => proto,
                    "aviatrix.ids.gateway" => gw_hostname
                }

                # Alert-specific fields
                if event_type == "alert"
                    log_event["aviatrix.ids.signature"] = signature
                    log_event["aviatrix.ids.severity"] = alert_severity
                    log_event["aviatrix.ids.category"] = category unless category.empty?
                    log_event["aviatrix.ids.signature_id"] = signature_id if signature_id
                    log_event["aviatrix.ids.gid"] = gid if gid
                    log_event["aviatrix.ids.rev"] = rev if rev
                end

                # Flow fields
                flow = data["flow"] || {}
                unless flow.empty?
                    log_event["aviatrix.ids.flow.pkts_toserver"] = flow["pkts_toserver"] if flow["pkts_toserver"]
                    log_event["aviatrix.ids.flow.pkts_toclient"] = flow["pkts_toclient"] if flow["pkts_toclient"]
                    log_event["aviatrix.ids.flow.bytes_toserver"] = flow["bytes_toserver"] if flow["bytes_toserver"]
                    log_event["aviatrix.ids.flow.bytes_toclient"] = flow["bytes_toclient"] if flow["bytes_toclient"]
                end

                # HTTP fields
                http = data["http"] || {}
                unless http.empty?
                    log_event["aviatrix.ids.http.hostname"] = http["hostname"] if http["hostname"]
                    log_event["aviatrix.ids.http.url"] = http["url"] if http["url"]
                    log_event["aviatrix.ids.http.method"] = http["http_method"] if http["http_method"]
                    log_event["aviatrix.ids.http.status"] = http["status"] if http["status"]
                end

                # TLS fields
                tls = data["tls"] || {}
                unless tls.empty?
                    log_event["aviatrix.ids.tls.sni"] = tls["sni"] if tls["sni"]
                    log_event["aviatrix.ids.tls.subject"] = tls["subject"] if tls["subject"]
                    if tls["ja3"].is_a?(Hash) && tls["ja3"]["hash"]
                        log_event["aviatrix.ids.tls.ja3_hash"] = tls["ja3"]["hash"]
                    end
                end

                event.set("[@metadata][dt_log_payload]", "[" + log_event.to_json + "]")
            '
        }
    }
}

# ===========================================================================
# OUTPUT — Two HTTP outputs: Metrics API + Logs API
# ===========================================================================

output {
    # Metrics: Send MINT payloads to Dynatrace Metrics Ingest API v2
    if [@metadata][dynatrace_mint_payload] {
        if ("gw_net_stats" in [tags] or "gw_sys_stats" in [tags]) and ("${LOG_PROFILE:all}" == "all" or "${LOG_PROFILE:all}" == "networking") {
            http {
                id => "dynatrace-metrics"
                http_method => "post"
                url => "${DT_METRICS_URL}"
                headers => {
                    "Authorization" => "Bearer ${DT_API_TOKEN}"
                }
                content_type => "text/plain; charset=utf-8"
                format => "message"
                message => "%{[@metadata][dynatrace_mint_payload]}"
                pool_max => 10
                pool_max_per_route => 5
                socket_timeout => 30
            }
        }
    }

    # Logs: Send JSON payloads to Dynatrace Logs Ingest API v2
    if [@metadata][dt_log_payload] {
        if (("suricata" in [tags] or "mitm" in [tags] or "microseg" in [tags] or "fqdn" in [tags] or "cmd" in [tags]) and ("${LOG_PROFILE:all}" == "all" or "${LOG_PROFILE:all}" == "security"))
           or ("tunnel_status" in [tags] and ("${LOG_PROFILE:all}" == "all" or "${LOG_PROFILE:all}" == "networking")) {
            http {
                id => "dynatrace-logs"
                http_method => "post"
                url => "${DT_LOGS_URL}"
                headers => {
                    "Authorization" => "Bearer ${DT_LOGS_TOKEN}"
                }
                content_type => "application/json; charset=utf-8"
                format => "message"
                message => "%{[@metadata][dt_log_payload]}"
                pool_max => 10
                pool_max_per_route => 5
                socket_timeout => 30
            }
        }
    }
}
