# CPU Cores Parser
# Parses protobuf-text cpu_cores field from AviatrixGwSysStats into structured JSON

# Step 1: Parse cpu_cores protobuf text into structured fields
filter {
    if "gw_sys_stats" in [tags] and [cpu_cores] and [cpu_cores] != "" {
        ruby {
            id => "cpu-cores-parse"
            code => '
                raw = event.get("cpu_cores")
                next unless raw.is_a?(String) && raw.length > 2

                # Strip outer brackets
                raw = raw.strip
                raw = raw[1..-2] if raw.start_with?("[") && raw.end_with?("]")

                # Tokenize into name:N and busy:{...} tokens with nested brace matching
                tokens = []
                i = 0
                while i < raw.length
                    # Skip whitespace
                    if raw[i] =~ /\s/
                        i += 1
                        next
                    end

                    # Match name:N token
                    if raw[i..] =~ /\Aname:(-?\d+)/
                        tokens << { type: :name, value: $1 }
                        i += $~[0].length
                        next
                    end

                    # Match busy:{...} token with nested brace matching
                    if raw[i..] =~ /\Abusy:\{/
                        depth = 0
                        start = i + 5  # skip "busy:"
                        j = start
                        while j < raw.length
                            if raw[j] == "{"
                                depth += 1
                            elsif raw[j] == "}"
                                depth -= 1
                                if depth == 0
                                    body = raw[start..j]
                                    tokens << { type: :busy, body: body }
                                    i = j + 1
                                    break
                                end
                            end
                            j += 1
                        end
                        # If we never closed braces, skip past what we matched
                        i = j + 1 if depth != 0
                        next
                    end

                    # Skip any unrecognized character
                    i += 1
                end

                next if tokens.empty?

                # Extract min/max/avg from a busy block body
                # Strips out start:{...} and end:{...} sub-blocks first
                extract_stats = lambda do |body|
                    # Remove nested start:{...} and end:{...} blocks
                    cleaned = body.gsub(/(?:start|end):\{[^}]*\}/, "")
                    stats = {}
                    cleaned.scan(/(min|max|avg):(\d+)/).each do |key, val|
                        stats[key] = val.to_i
                    end
                    stats
                end

                # Detect format: name-first vs busy-first
                name_first = tokens[0][:type] == :name

                # Pair tokens into core entries
                cores = []
                if name_first
                    pending_name = nil
                    tokens.each do |tok|
                        if tok[:type] == :name
                            pending_name = tok[:value]
                        elsif tok[:type] == :busy
                            stats = extract_stats.call(tok[:body])
                            entry = {}
                            entry["name"] = pending_name if pending_name
                            entry["busy_min"] = stats["min"] if stats["min"]
                            entry["busy_max"] = stats["max"] if stats["max"]
                            entry["busy_avg"] = stats["avg"] if stats["avg"]
                            cores << entry
                            pending_name = nil
                        end
                    end
                else
                    # busy-first: each busy optionally consumes the following name
                    idx = 0
                    while idx < tokens.length
                        tok = tokens[idx]
                        if tok[:type] == :busy
                            stats = extract_stats.call(tok[:body])
                            entry = {}
                            # Check if next token is a name
                            if idx + 1 < tokens.length && tokens[idx + 1][:type] == :name
                                entry["name"] = tokens[idx + 1][:value]
                                idx += 1
                            end
                            entry["busy_min"] = stats["min"] if stats["min"]
                            entry["busy_max"] = stats["max"] if stats["max"]
                            entry["busy_avg"] = stats["avg"] if stats["avg"]
                            cores << entry
                        elsif tok[:type] == :name
                            # Standalone name followed by busy
                            if idx + 1 < tokens.length && tokens[idx + 1][:type] == :busy
                                stats = extract_stats.call(tokens[idx + 1][:body])
                                entry = { "name" => tok[:value] }
                                entry["busy_min"] = stats["min"] if stats["min"]
                                entry["busy_max"] = stats["max"] if stats["max"]
                                entry["busy_avg"] = stats["avg"] if stats["avg"]
                                cores << entry
                                idx += 1
                            end
                        end
                        idx += 1
                    end
                end

                next if cores.empty?

                # Set parsed array
                event.set("cpu_cores_parsed", cores)

                # Extract aggregate (name=-1) and individual core stats
                aggregate = nil
                individual_count = 0
                cores.each do |c|
                    if c["name"] == "-1"
                        aggregate = c
                    elsif c["name"] && c["name"] != "-1"
                        individual_count += 1
                    end
                end

                if aggregate
                    event.set("cpu_aggregate_busy_min", aggregate["busy_min"]) if aggregate["busy_min"]
                    event.set("cpu_aggregate_busy_max", aggregate["busy_max"]) if aggregate["busy_max"]
                    event.set("cpu_aggregate_busy_avg", aggregate["busy_avg"]) if aggregate["busy_avg"]
                    # cpu_busy: prefer avg, fall back to max
                    if aggregate["busy_avg"]
                        event.set("cpu_busy", aggregate["busy_avg"])
                    elsif aggregate["busy_max"]
                        event.set("cpu_busy", aggregate["busy_max"])
                    end
                end

                # Fallback: compute cpu_busy from cpu_idle if no aggregate found
                if !aggregate
                    cpu_idle = event.get("cpu_idle")
                    if cpu_idle
                        idle_val = cpu_idle.is_a?(Numeric) ? cpu_idle : cpu_idle.to_f
                        event.set("cpu_busy", (100 - idle_val).round(1))
                    end
                end

                event.set("cpu_core_count", individual_count) if individual_count > 0
            '
        }
    }
}
